# read spectra ----------------------------------------------------------------------
readSpec_checkDefaults <- function(possibleFiletypes, md, filetype, naString) {
	if (all(filetype == "def")) {
		filetype <- .ap2$stn$imp_specFileType
	} else {
		if (!all(is.character(filetype)) | length(filetype) != 1) {
			stop("Please provide a character length one to the argument 'filetype'. Refer to the help for 'getFullData' for possible values.", call.=FALSE)
		}
	}
	if (grepl("custom@", filetype)) {
		custName <- strsplit(filetype, "custom@")[[1]][2]
		pathSH <- Sys.getenv("AQUAP2SH")
		if (!file.exists(paste(pathSH, custName, sep="/"))) {
 			stop(paste("The file \"", custName, "\" that contains the custom-function for importing of raw-spectra does not seem to exist in \n\"", pathSH, "\".\n", sep=""), call.=FALSE)
		} else {
			fc <- filetype
		}
	} else {
		fc <- NULL
	}
	possValues <- c(possibleFiletypes, fc) # so we are sure that we have a valid filename under fc 
	if (!any(possValues %in% filetype)) {
		stop("Please refer to the help for 'getFullData' for possible values for the argument 'filetype'. Have a good day.", call.=FALSE)
	}
	assign("filetype", filetype, pos=parent.frame(n=1))
	###
	if (!all(is.character(naString)) | length(naString) != 1) {
		stop("Please provide a character length one to the argument 'naString'.", call.=FALSE)
	}
	###
	if (class(md) == "aquap_md") {
		filename <- md$meta$expName
	} else {
		stop("Please provide a valid metadata object to the argument 'md'", call.=FALSE)
	}
	rawFolder <- .ap2$stn$fn_rawdata
	a <- list.files(rawFolder)
	if (!any(grepl(filename, a, fixed=TRUE))) {
		stop(paste("The file \"", filename, "\" does not seem to exist in \"", rawFolder, "\", sorry. \n", sep=""), call.=FALSE)
	}
	assign("filename", filename, pos=parent.frame(n=1))
} # EOF


#' @title Read Spectra
#' @description Reads in just the spectra from the provided rawdata file.
#' @details This function is mainly for providing a possibility to test custom 
#' written rawdata import functions. (see \code{\link{custom_import}})
#' @inheritParams getFullData
#' @return The spectral data in the format as described in 'Value' in 
#' \code{\link{custom_import}}
#' @seealso \code{\link{getFullData}}
#' @family Development
#' @export
readSpectra <- function(md=getmd(), filetype="def", naString="NA") {
	autoUpS()
	possibleFiletypes <- c("vision_NSAS.da", "tabDelim.txt") # they get handed down to the checking function !  # XXVARXX
	filename <- NULL # will be changed in the checking
	readSpec_checkDefaults(possibleFiletypes, md, filetype, naString)
	rawFolder <- .ap2$stn$fn_rawdata
	folderFile <- paste(rawFolder, "/", filename, sep="")
	##
	if (filetype == "vision_NSAS.da") {
		a <- paste(folderFile, ".da", sep="")
		return(getNIRData_Vision_da(a))
	}
	##
	if (filetype == "tabDelim.txt") {
		a <- paste(folderFile, ".txt", sep="")
 		return(getNirData_plainText(a, naString))
	}
	## if nothing of the above happend, then we must have (checked!) the path to a valid custom .r file in "filetype" 
	custName <- strsplit(filetype, "custom@")[[1]][2]
	pathSH <- Sys.getenv("AQUAP2SH")
	pathToCustom <- paste(pathSH, custName, sep="/")
	e <- new.env()
	sys.source(pathToCustom, envir=e)
	a <- paste(folderFile, e$fileExtension, sep="")
	assign("spectraFilePath", a, pos=parent.frame(n=1))
	return(e$spectralImport(a))
} # EOF

gfd_check_imports <- function(specImp) {
#	outList <- list(sampleNr=sampleNr, conSNr=conSNr, timePoints=timePoints, ecrm=ecrm, repl=repl, group=group, temp=temp, relHum=relHum, C_cols=C_cols, Y_cols=Y_cols, timestamp=timestamp, info=info, NIR=NIR)
	namesOfListElements <- c("sampleNr", "conSNr", "timePoints", "ecrm", "repl", "group", "temp", "relHum", "C_cols", "Y_cols", "timestamp", "info", "NIR") ## XXXVARXXX
	if (!all(names(specImp) %in% namesOfListElements)) {
		stop("One or more of the elements in the list of your custom import function do have wrong names. \nPlease see the help for 'custom_import' for further information.", call.=FALSE)
	}
	namesOfInfoList <- c("nCharPrevWl") 	## XXXVARXXX
	if (!all(names(specImp$info) %in% namesOfInfoList)) {
		stop("One or more of the elements in the info-list generated by your custom import function do have wrong names. \nPlease see the help for 'custom_import' for further information.", call.=FALSE)		
	}
	a <- specImp$sampleNr
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'sampleNr' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$conSNr
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'conSNr' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$timePoints
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'timePoints' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$ecrm
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'ecrm' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$repl
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'repl' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$group
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'group' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$temp
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'temp' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$relHum
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'relHum' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$C_cols
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'C_cols' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$Y_cols
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'Y_cols'" ), call.=FALSE)
		}
	}
	a <- specImp$timestamp
	if (!is.null(a)) {
		if (!is.data.frame(a)) {
			stop(paste("Please provide a data frame for the element 'timestamp' in the import function."),call.=FALSE)
		}
	}
	if (!is.null(specImp$NIR)) {
		if (!is.matrix(specImp$NIR)) {
			stop(paste("Please provide a matrix for the element 'NIR' in the import function."),call.=FALSE)
		}
	}
	a <- specImp$info$nCharPrevWl
	if (!all(is.numeric(a)) | length(a) !=1) {
		stop(paste("Please provide an integer length 1 for the element 'nCharPrevWl' in the import function."),call.=FALSE)
	}
	a <- specImp$info$nCharPrevWl
	if (!all(is.numeric(a)) | length(a) !=1) {
		stop("Please provide a length one numeric as the input for the element 'nCharPrevWl' in the import function", call.=FALSE)
	}
	ncpwl <- specImp$info$nCharPrevWl
	options(warn = -1)
	a <- as.numeric(substr(colnames(specImp$NIR), ncpwl+1, nchar(colnames(specImp$NIR))))
	options(warn = 0)
	if (any(is.na(a))) {
		stop("There is an error with the column names of the NIR spectra representing the wavelength. \nMaybe not all columns do have the same number of characters before the wavelength. \nPlease check in the import function if the provided number of characters before the wavelength is correct, and if the column names of the NIR data are correct as well.", call.=FALSE)
	}
} # EOF

gfd_makeColumnNames <- function(specImp) {
	yPref <- .ap2$stn$p_yVarPref
	cPref <- .ap2$stn$p_ClassVarPref
	sampleNrColn <- .ap2$stn$p_sampleNrCol
	conSNrColn <- .ap2$stn$p_conSNrCol
	timePointsColn <- .ap2$stn$p_timeCol
	ecrmColn <- .ap2$stn$p_ECRMCol
	replColn <- .ap2$stn$p_replicateCol
	groupColn <- .ap2$stn$p_groupCol
	tempColn <- .ap2$stn$p_tempCol
	relHumColn <- .ap2$stn$p_RHCol
	nr <- nrow(specImp$NIR)
	##
	if (!is.null(specImp$sampleNr)) {
		colnames(specImp$sampleNr) <- paste(cPref, sampleNrColn, sep="")
	}
	if (!is.null(specImp$conSNr)) {
		colnames(specImp$conSNr) <- paste(yPref, conSNrColn, sep="")
	}
	if (!is.null(specImp$timePoints)) {
		colnames(specImp$timePoints) <- paste(cPref, timePointsColn, sep="")
	}
	if (!is.null(specImp$ecrm)) {
		colnames(specImp$ecrm) <- paste(cPref, ecrmColn, sep="")
	}
	if (!is.null( specImp$repl)) {
		colnames(specImp$repl) <- paste(cPref, replColn, sep="")
	}
	if (!is.null(specImp$group)) {
		colnames(specImp$group) <- paste(cPref, groupColn, sep="")
	}
	if (!is.null(specImp$temp)) {
		colnames(specImp$temp) <- paste(yPref, tempColn, sep="")
	}
	if (!is.null(a)) {
		colnames(specImp$relHum) <- paste(yPref, relHumColn, sep="")
	}
	if (!is.null(specImp$C_cols)) {
		lePref <- nchar(cPref)
		a <- colnames(specImp$C_cols)
		noPrefInd <- which(substr(a, 1, lePref) != cPref)
		if (length(noPrefInd) > 0) {
			colnames(specImp$C_cols)[noPrefInd] <- paste(cPref, a[noPrefInd], sep="")
		}
	}
	if (!is.null(specImp$Y_cols)) {
		lePref <- nchar(yPref)
		a <- colnames(specImp$Y_cols)
		noPrefInd <- which(substr(a, 1, lePref) != yPref)
		if (length(noPrefInd) > 0) {
			colnames(specImp$Y_cols)[noPrefInd] <- paste(yPref, a[noPrefInd], sep="")
		}
	}
	if (!is.null(specImp$timestamp)) {
		colnames(specImp$timestamp) <- "Timestamp"
	}
	return(specImp)
} # EOF


gfd_checkNrOfRows <- function(header, headerFilePath, nrowsNIR, spectraFilePath) {
	if (!is.null(header)) {
		if (nrow(header) != nrowsNIR) {
			stop(paste("The header that was constructed from the file \n\"", headerFilePath, "\"\n consists of ", nrow(header), " rows, while the imported spectra from file \n\"", spectraFilePath, "\"\n consist of ", nrowsNIR, " rows. \nPlease make sure that all data to be imported have the same number of rows.", sep=""), call.=FALSE)
		}
	}
} # EOF

#' @rdname getFullData
#' @export
gfd <- function(md=getmd(), filetype="def", naString="NA", slType="def", multiplyRows="def",  stf=TRUE) {
	return(getFullData(md, filetype, naString, slType, multiplyRows, stf))
} # EOF


# get full data ---------------------------------------------------------------
#' @rdname getFullData
#' @export
getFullData <- function(md=getmd(), filetype="def", naString="NA", slType="def", multiplyRows="def",  stf=TRUE) {
	autoUpS()
	cPref <- .ap2$stn$p_ClassVarPref
#	outList <- list(sampleNr=sampleNr, conSNr=conSNr, timePoints=timePoints, ecrm=ecrm, repl=repl, group=group, temp=temp, relHum=relHum, C_cols=C_cols, Y_cols=Y_cols, timestamp=timestamp, info=info, NIR=NIR)
	headerFilePath <- NULL # gets assigned in readHeader()
	header <- readHeader(md, slType, multiplyRows) # re-assigns 'slType' also here -- in parent 2 level frame ## if slType is NULL, header will be returned as NULL as well
	spectraFilePath <- NULL # gets assigned in readSpectra()
	specImp <-  readSpectra(md, filetype, naString) ### !!!!!!!!! here the import !!!!!!!!!
	gfd_check_imports(specImp) # makes sure eveything is NULL or data.frame / matrix (NIR)
	specImp <- gfd_makeColumnNames(specImp) # makes all column names
	gfd_checkNrOfRows(header, headerFilePath, nrow(specImp$NIR), spectraFilePath) 
	if (is.null(header)) {
		header <- data.frame(rep(NA, nrow(specImp$NIR)))
	}
#	return(specImp)
	
		sampleNr <- specImp$sampleNr
		conSNr <- specImp$conSNr
		timePoints <- specImp$timePoints
		ecrm <- specImp$ecrm
		repl <- specImp$repl
		group <- specImp$group
		temp <- specImp$temp
		relHum <- specImp$relHum
		C_cols <- specImp$C_cols
		Y_cols <- specImp$Y_cols
		timestamp <- specImp$timestamp
		info <- specImp$info			# 	info <- list(nCharPrevWl=nCharPrevWl)
		NIR <- specImp$NIR
	nr <- nrow(NIR)
	expName <- data.frame(rep(md$meta$expName, nr))
	colnames(expName) <- paste(cPref, .ap2$stn$p_expNameCol)
	noSplit <- data.frame(rep(.ap2$stn$p_commonNoSplit, nr))
	colnames(noSplit) <- paste(cPref, .ap2$stn$p_commonNoSplitCol)
#	headerFusion <- cbind(expName, noSplit, sampleNr, conSNr, timePoints, ecrm, repl, group, C_cols, Y_cols,  temp, relHum, timestamp)
	headerFusion <- cbind(expName, noSplit, sampleNr, timePoints, ecrm, repl, group, C_cols, Y_cols,  temp, relHum)
	
	return(headerFusion)
	
	
	cns <- colnames(addCols)
	##
	indT <- which(cns == "Timestamp")
	if (length(ind) != 0) {
		timestamp <- addCols[ind]
	} else {
		timestamp <- data.frame(Timestamp = rep(NA, nrow(NIR)))
	}
	##
	if (ncol(addCols) > 1) {
		addColsRest <- as.data.frame(addCols[, -indT])
	} else {
		addColsRest <- NULL
	}
	headerFusion <- cbind(header, addColsRest, timestamp)
	if (.ap2$stn$imp_autoCopyYvarsAsClass) {  # if TRUE, copy all columns containing a Y-variable as class variable
		header <- copyYColsAsClass(headerFusion)
	}
	headerFusion <- remakeTRHClasses_sys(headerFusion)
	numRep <- extractClassesForNumRep(headerFusion)		## the numerical representation of the factors
	chrons <- NULL
	fullData <- data.frame(headerFusion, timeStamp, chrons, I(numRep), I(NIR))		### FUSION HERE 
	return(fullData)
	## to do: correct the globals in the color-functions, add possibility to replace temp and relhum by columns in the spectral data?, test the placement of the additional columns, write the documentation in the make custom doc file
} # EOF

# refine header -------------------------------------------------------------
transformNrsIntoColorCharacters <- function(numbers) {
	whatColors = c("black", "red", "green", "blue", "cyan", "magenta", "yellow2", "gray")
	colRamp <- colorRampPalette(whatColors)
	colorChar <- colRamp(length(unique(numbers))) 		## XXX unique needed here?
	return(as.character(colorChar[numbers]))
} # EOF

generateHeatMapColorCoding <- function(numbers) {
	whatColors <- get("stngs")$colorRampForTRH
	colRamp <- colorRampPalette(whatColors)
	colorChar <- colRamp(length(unique(numbers)))
	out <- as.character(colorChar[numbers])
} # EOF

extractClassesForNumRep <- function(header) { ## does not need "NIR" present in the data frame
	tempCol <- get("stngs")$tempCol ## depends on "grepl" or not
	RHCol <- get("stngs")$RHCol
	out <- data.frame(matrix(NA, nrow=nrow(header)))
	for (i in 1: ncol(header)) {
		if (is.factor(header[,i])) {
			a <- data.frame( as.numeric(unclass(header[,i])))
			levelsA <- unique(a[,1])
			cn <- colnames(header[i])
			if (grepl(tempCol, cn) | grepl(RHCol, cn)) {
				a[1] <- generateHeatMapColorCoding(a[,1])
			} else {
				if (length(levelsA) > 8) { ## we only have 8 integer representations for colors
					a[1] <- transformNrsIntoColorCharacters(a[,1])
				} # end if
			}
			names(a) <- colnames(header[i])
			out <- data.frame(out,a)
		} # end if 
	} # end for i
	return(out[-1])		# cut off the first column containing only the NAs
} # EOF 

copyYColsAsClass <- function(sampleList) {
	yPref <- .ap2$stn$p_yVarPref
	cPref <- .ap2$stn$p_ClassVarPref
	ind  <- grep(yPref, colnames(sampleList))
#	print(ind); wait()
#	print(colnames(sampleList[ind])); wait()
	add <- data.frame(matrix(NA,nrow(sampleList)))
	for (i in 1: length(ind)) {
		colName <- names(sampleList[ind[i]])
		newColName <- sub(yPref, cPref, colName)
		numCol <- sampleList[, ind[i] ]
		factorCol <- factor(as.character(numCol), exclude=NA) 
		newDF <- data.frame(factorCol)
		names(newDF)[1] <- newColName
		add <- data.frame(add, newDF )
	}
	add <- add[-1]
	out <- data.frame(sampleList, add)
	return(out)
} # EOF

remakeTRHClasses_sys <- function(headerOnly, TDiv=.ap2$stn$imp_TClassesDiv, TRound=.ap2$stn$imp_TRounding, RHDiv=.ap2$stn$imp_RHClassesDiv, RHRound= .ap2$stn$imp_RHRounding) {
	options(warn=-1)
	cPref <- .ap2$stn$p_ClassVarPref
	Tpat <- paste(cPref, .ap2$stn$p_tempCol, sep="") 						# read in the prefix for class and temperature from settings
	RHpat <- paste(cPref, .ap2$stn$p_RHCol, sep="")							# read in the prefix for class and rel. humidity from settings
	TInd <- grep(.ap2$stn$p_tempCol, colnames(headerOnly), fixed=TRUE)		# find column-index that has the temperatur - the source
	TClInd  <- grep(Tpat, colnames(headerOnly), fixed=TRUE)					# find column-index that the temperatur already as class - the target
	RHInd <- grep(.ap2$stn$p_RHCol, colnames(headerOnly), fixed=TRUE)		# find column-index that has the rel. hum.
	RHClInd  <- grep(RHpat, colnames(headerOnly), fixed=TRUE)				# find column-index that the re.hum. already as class - the target
	numsTemp <- headerOnly[, TInd[1] ]										# extract the numbers
	numsRH <- headerOnly[, RHInd[1] ]										# extract the numbers
	headerOnly[TClInd] <- factor(round((numsTemp/TDiv),TRound)*TDiv)		# insert the new classes
	headerOnly[RHClInd] <- factor(round((numsRH/RHDiv),RHRound)*RHDiv)		# insert the new classes
	options(warn=0)
	return(headerOnly)
} # EOF

# read header ----------------------------------------------------------------
convertYColsToNumeric <- function(sampleList) {
	options(warn=-1)
	pref <- .ap2$stn$p_yVarPref
	ind  <- grep(pref, colnames(sampleList))
	for (i in 1: length(ind)) {
		sampleList[ind[i]] <- as.numeric( as.character(sampleList[, ind[i]]) )
	}
	options(warn=0)
	return(sampleList)
} # EOF

### x-fold every line (Nr. Cons. Measurements), and add a numbering for each of the consecutive scans
multiplySampleListRows <- function(sampleList, nrScans) {
	multiList <- NULL
	for (i in 1:nrScans) {
		multiList <- rbind(multiList, sampleList)
	} # end i loop
	second <- matrix(rep(1:nrScans, each=nrow(sampleList) ))
	first <- matrix(rep(1:nrow(sampleList), nrScans) )
	a <- data.frame(multiList, second=second, first=first)
	a <- a[order(first, second), ][,1:(ncol(a)-2)] # order, then cut away the last two columns
	ConSNr <- rep(1:(nrScans),nrow(sampleList)) # generate a vector numbering all the consecutive scans
	a <- data.frame(a[1], ConSNr=ConSNr, a[-1]) # insert into data frame
	ColNames <- colnames(a)
	ColNames[2] <- paste(.ap2$stn$p_yVarPref, .ap2$stn$p_conSNrCol, sep="")
	colnames(a) <- ColNames
	rownames(a) <- seq(1:nrow(a)) # correct all the rownames
	return(a)
} # EOF

readHeader_checkDefaults <- function(slType, possibleValues, md, multiplyRows) {
	if (all(slType == "def") & !is.null(slType)) {
		slType <- .ap2$stn$imp_sampleListType
	}
	if (!is.null(slType)) {
		if (!all(is.character(slType)) | length(slType) != 1) {
			stop("Please provide a character length one or NULL to the argument 'slType'.", call.=FALSE)
		}
	}
	if (!any(possibleValues %in% slType) & !is.null(slType)) {
		stop("Please refer to the help for 'getFullData' for the possible values for the argument 'slType'", call.=FALSE)
	}
	assign("slType", slType, pos=parent.frame(n=1))
	assign("slType", slType, pos=parent.frame(n=2)) # that is needed to always have the correct value for slType in the getFullData function
	###
	if (class(md) == "aquap_md") {
		filename <- md$meta$expName
	} else {
		stop("Please provide a valid metadata object of class 'aquap_md' to the argument 'md'", call.=FALSE)
	}
	assign("filename", filename, pos=parent.frame(n=1))
	###
	if (all(multiplyRows == "def")) {
		multiplyRows <- .ap2$stn$imp_multiplyRows
	} else {
		if (!all(is.logical(multiplyRows)) | length(multiplyRows) != 1) {
			stop("Please provide either 'TRUE' or 'FALSE' to the argument 'multiplyRows'.", call.=FALSE)
		}
	}
	assign("multiplyRows", multiplyRows, pos=parent.frame(n=1))
} # EOF

check_sl_existence <- function(filename, ext) {
	slInFolder <- paste(.ap2$stn$fn_sampleLists, "/", .ap2$stn$f_sampleListIn, sep="")
	fn <- paste(filename, ext, sep="")
	a <- paste(slInFolder, "/", fn, sep="")
	if (!file.exists(a)) {
		stop(paste("The file \"", fn, "\" does not seem to exist in \"", slInFolder, "\".", sep=""), call.=FALSE)
	}	
	
} # EOF

check_conScanColumn <- function(header, filename, ext) {
	a <- paste(.ap2$stn$p_yVarPref, .ap2$stn$p_conSNrCol, sep="")
	if (!any(a %in% colnames(header))) {
		stop(paste("You do not have a column for the nr of the consecutive scan in your sample list called \"", filename, ext, "\". \nPlease, add a column called \"", a, "\" to the file as the second column and provide the right values in this column. \n(You probably encounter this error because you did choose to *not* multiply the rows of the sample list by the nr. of consecutive scans.)\nPlease refer to the help for 'getFullData' for further information.", sep=""), call.=FALSE)
	}
	ind <- grep(a, colnames(header), fixed=TRUE)
	if (ind != 2) {
		stop(paste("Your 'custom-column' for the number of the consecutive scan should, please, be the second column. \nPlease modify the file \"", filename, ext, "\" accordingly.", sep=""), call.=FALSE)
	}
} # EOF

#' @title Read Header
#' @description This functions reads in the sample-list file and prepares the 
#' header to be fused with the spectral data. 
#' Usually you do not need to call this function.
#' @details  From the metadata, provided in the first argument, the experiment 
#' name is extracted; the sample list (what is used to create the header) must be in the 
#' sampleLists/sl_in folder and must be named with the experiment name, followed 
#' by a "-in" and then the file extension.
#' @inheritParams getFullData
#' @seealso \code{\link{getFullData}}
#' @examples
#' \dontrun{
#'  header <- readHeader()
#' }
#' @family Development
#' @export
readHeader <- function(md=getmd(), slType="def", multiplyRows="def") {
	autoUpS()
	poss_sl_types <- c("csv", "txt", "xls") 			### XXXVARXXX
	filename <- NULL # will be changed in the checking
	readHeader_checkDefaults(slType, poss_sl_types, md, multiplyRows)
	slInFolder <- paste(.ap2$stn$fn_sampleLists, "/", .ap2$stn$f_sampleListIn, "/", sep="")
	if (is.null(slType)) {
		return(NULL)
	}
	if (slType == "csv") {
		ext <- "-in.csv"
		check_sl_existence(filename, ext)
		rawHead <- read.csv(paste(slInFolder, filename, ext, sep=""))
	}
	if (slType == "txt") {
		ext <- "-in.txt"
		check_sl_existence(filename, ext)
		rawHead <- read.table(paste(slInFolder, filename, ext, sep=""), header=TRUE)
	}
	if (slType == "xls") {
		ext <- "-in.xlsx"
		check_sl_existence(filename, ext)
		rawHead <- xlsx::read.xlsx(paste(slInFolder, filename, ext, sep=""), sheetIndex=1, header = TRUE)
	}
	assign("headerFilePath", paste(slInFolder, filename, ext, sep=""), pos=parent.frame(n=1))
	###
	rawHead <- convertYColsToNumeric(rawHead)
	nrScans <- md$postProc$nrConScans
	if (multiplyRows) {
		header <- multiplySampleListRows(rawHead, nrScans)
	} else {
		header <- rawHead
		check_conScanColumn(header, filename, ext)
	}
	return(header)
} # EOF


## maybe add here the user-function for re-making the T and RH classes
# XXX


## next: add experiment name to the dataset, make import of spectra clean; add the common-value column; add expeirment name column; check rownames; check for existence of consSNr (is a must have)
## note: make @numRep in Aquacalc to take numerics OR character, because if we have more than 8 elements...  :-)

